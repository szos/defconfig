#+TITLE: DEFCONFIG
*** Status [[https://travis-ci.com/szos/defconfig.svg?branch=main]]
    Currently tested against SBCL, CCL, ABCL, ECL, and Allegro CL. 
* Purpose
  Defconfig is a customization and validation framework for places in CL. Its intended use is with user-exposed variables and accessors, to protect users from setting variables to an invalid value an potentially encountering undefined behavior. It can be used with both dynamic variables and ~setf~-able functions. It coexists alongside ~setf~, and does not replace it - ie you can still use ~setf~ if you want to avoid validating the value. 
  
  Defconfig is still in its infancy; symbols will be changed, other symbols will be exported, and functionality may change. For this reason, do not ~:use~ defconfig. Instead ~:import~ the symbols you want to use - namely ~#:defconfig~, ~#:setv~, ~#:with-atomic-setv~, ~#:define-defconfig-db~, ~#:get-db~, and ~#:*setv-permissiveness*~. 

  If you encounter something that doesnt work as you think it should, please open an issue here. If you describe the exhibited behavior and the expected behavior, it will be added to the test suite and fixed (hopefully quickly). 

* Usage
  The basic usage of this system is through the macros ~defconfig~, ~setv~ and ~with-atomic-setv~. The macro ~defconfig~ defines a configuration object which is used to check values against a predicate. The macro ~setv~ uses these configuration objects to validate values before calling setf. An error is signalled if A) the value is invalid, B) the coerced value is invalid (when applicable) or C) the place one is trying to set doesnt have a configuration object. For A and B, restarts are put into place to ignore the invalidity and set regardless. The macro ~with-atomic-setv~ collects all places set with ~setv~ in its body and if an error is signalled resets all changed values back to their original value before the ~with-atomic-setv~ form. 

* Regarding This Readme
  This readme is not a complete explanation of defconfig. Please see =package.lisp= for a list of exported symbols and see the symbol docstrings for a better idea of what it does. Most (exported) symbols are well documented, slots have decent documentation describing their purpose/use, and errors should be grokkable from their ~:report~ functions.

* Basic Tutorial
  Lets look at an example where one is defining a user-exposed variable for the background color of an application. Please see =tests/defconfig-tests.lisp= for more examples.

** Defconfig
   Here we define a variable called ~*background-color*~ which holds a default value of the color white. It may only hold a color object. If we try to set it to a string, we try to parse a color object from the string. If that fails or we get something other than a string, we return the original value. We do this because the coercer is only ever called on an invalid value, and if we cannot make a color object from it we want to be certain that we return an invalid value. We then tag the configuration object with “color” and “background” such that it can be searched for by those names.
#+BEGIN_SRC lisp
  (defpackage :my-app
    (:local-nicknames (:dc :defconfig))
    (:use :cl))

  (in-package :my-app)

  (defstruct color r g b)

  (defun parse-color-from-string (string)
    (make-color :r (parse-integer (subseq string 0 2) :radix 16)
		:g (parse-integer (subseq string 2 4) :radix 16)
		:b (parse-integer (subseq string 4 6) :radix 16)))

  (dc:defconfig *background-color* (make-color :r 256 :g 256 :b 256)
    :documentation "the background color for my app"
    :typespec 'color
    :coercer (lambda (value)
	       (handler-case (parse-color-from-string value)
		 (error () value)))
    :tags '("color" "background"))
#+END_SRC

** Setv
   Now, somewhere in the users =~/.myapp.d/init=, they want to set the background color to black. Lets look at three examples of that: 
#+BEGIN_SRC lisp
  (dc:setv *background-color* (make-color :r 0 :g 0 :b 0))
  (dc:setv *background-color* "000000")
  (dc:setv *background-color* "i dont know what this user is thinking!")
#+END_SRC
   The first of these works without a hitch; ~setv~ determines that it is a valid value as per the typespec the user provided, and sets ~*background-color*~ to black. 

   The second of these would fail if we hadnt provided a coercer, but as we did, and it knows how to handle color strings, we generate a color from the color string and ~*background-color*~ gets set to black. 

   The third of these is also a string, but its impossible to parse a color from it. Assuming ~parse-color-from-string~ errors out on invalid strings, we return ~value~ and signal an error; ~*background-color*~ remains white. 

** With-atomic-setv 
   Lets look at an example of ~with-atomic-setv~. We will define a bounded number variable, and then try setting it while signalling various errors. 
#+BEGIN_SRC lisp
  (dc:defconfig *bounded-number* 0
    :typespec '(integer 0 10)
    :coercer (lambda (x)
	       (if (stringp x)
		   (handler-case (parse-integer x)
		     (error () x))
		   x)))

  (defun compute-something-that-signals-an-error ()
    (error "we encountered an error, oh no!"))

  (dc:with-atomic-setv ()
    (dc:setv *bounded-number* 1)
    (dc:setv *bounded-number* 50))

  (dc:with-atomic-setv ()
    (dc:setv *bounded-number* 1)
    (compute-something-that-signals-an-error)
    (dc:setv *bounded-number* 2))

  (dc:with-atomic-setv (:handle-conditions dc:config-error)
    (dc:setv *bounded-number* 1)
    (compute-something-that-signals-an-error)
    (dc:setv *bounded-number* 2))
#+END_SRC
   The first of the calls to ~with-atomic-setv~ first sets ~*bounded-number*~ to 1, and then encounters an error when trying to set it to 50. It catches that error and resets ~*bounded-number*~ to 0, the value ~*bounded-number*~ had before the call to ~with-atomic-setv~. 

   The second of these first sets ~*bounded-number*~ to 1, and then an error is signalled by ~(compute-something-that-signals-an-error)~. It catches this error and resets ~*bounded-number*~ to 0. 

   The third of these first sets ~*bounded-number*~ to 1, and then an error is signalled that it is not set up to handle; it will only catch errors of type ~config-error~. Whether or not it attempts to set ~*bounded-number*~ to 2 is determined by what handlers and restarts are set up around the error. If there is a restart that doesnt unwind the stack then ~*bounded-number*~ will be set to 2, but if there is a non-local transfer of control to a point outside of ~with-atomic-setv~ then ~*bounded-number*~ will remain set to 1. This is the only way to escape ~with-atomic-setv~ that leaves things in a partially configured state. Lets look at an example of this that would end up with ~*bounded-number*~ being 2: 
#+BEGIN_SRC lisp
  (defun compute-something-that-signals-an-error ()
    (restart-case (error "we encountered an error, oh no!")
      (continue () nil)))

  (handler-bind ((error
		   (lambda (c)
		     (declare (ignore c))
		     (when (find-restart 'continue)
		       (invoke-restart 'continue)))))
    (dc:with-atomic-setv (:handle-conditions dc:config-error)
      (dc:setv *bounded-number* 1)
      (compute-something-that-signals-an-error)
      (dc:setv *bounded-number* 2)))
#+END_SRC

** Controlling Permissiveness
   By setting ~*setv-permissiveness*~ one can control how ~setv~ handles missing configuration objects. It can be set to one of the following values: 
   - ~:strict~ - Signal all errors as they occur. This is the default behavior
   - ~:greedy~ - When unable to find a configuration object in the specified database, search in all databases for a matching configuration object, using the first one encountered.
   - ~:permissive~ - When a configuration object isnt found, set the variable to the value.
   - ~:greedy+permissive~ - When a configuration object isnt found, search for one as per ~:greedy~. If one still isnt found, set the variable to the value. 
     
* A Note About Reset-Place
  The macro ~reset-place~ (and by extension the function ~reset-computed-place~) could be a little confusing. It takes a place, and resets it to its default value. However if ~previous-value~ is true, then it resets to the previous value instead. Before setting, it checks if the current value is eql to the value to reset to (this can be controlled with ~already-reset-test~) and if it is it isnt reset as it would have no effect. If it isnt, we both reset the place, AND set the ~previous-value~ slot to the (now no longer) current value. thusly, if the default value is a, previous value is b, and current value is c, and we reset to the default value, we will have a default of a, previous of c, and current of a. If we had instead reset to the previous value, we effectively swap the previous and current values. 
  Furthermore, we cannot reset accessor places.

* Macros
** Defconfig
   The ~defconfig~ macro generates a config-info object and registers it in a database. The signature is *defconfig* /place default-value &key validator typespec coercer reinitialize regen-config name documentation tags db/ => /config-info/
   - *Side Effects*:
     - Causes the /config-info/ object to be placed into /db/
     - May cause /place/ to be set to /default-value/
     - May cause /place/ to be defined in the global scope
     - Any side effects of running /validator/.
   - Arguments and Values
     - /place/ - either a symbol or a list denoting a setf-able function
     - /default-value/ - the default value for /place/. Must conform to /validator/ or /typespec/ when provided
     - /validator/ - a function of one argument which returns true when its argument is valid for /place/ and nil when it is invalid. May not be provided alongside /typespec/
     - /typespec/ - a type specifier denoting valid types for /place./ May not be provided alongside /validator/
     - /coercer/ - a function of one argument which should attempt to coerce its argument to a valid value.
     - /reinitialize/ - when true, and /place/ is a symbol, will reinitialize place by generating a defparameter form with /place/, /default-value/, and /documentation/. 
     - /regen-config/ - when true /config-info/ will be regenerated and replace any preexisting object.
     - /name/ - the name to give /config-info/.
     - /documentation/ - documentation for /config-info/. Will also be used for any generated defvar or defparameter form.
     - /tags/ - a list of strings used in searching for a config object.
     - /db/ - the database to place /config-info/ into. 
** Setv
   The ~setv~ macro expands into multiple calls to ~%setv~, which validates a value before setting the place to it. It functions the same as ~setf~, but accepts the keyword ~:db~ to specify a database other than the default one provided by ~defconfig~. Returns the final value. 
   - *Side Effects*:
     - Any side effects of evaluating a value. All values are evaluated sequentially. If a value is not valid, no further values will be processed.
     - Causes /place/ to be set to /value/ 
** With-atomic-setv
   NB: ~with-atomic-setv~ does not currently work with accessor places. Use ~with-atomic-setv*~ instead. It is currently under tested, but (should) function the same as ~with-atomic-setv~. 

   The ~with-atomic-setv~ macro resets any places set using ~setv~ to the value it held before the call to ~with-atomic-setv~, when a condition is encountered. One can specify whether to re-signal the condition or not with ~:re-error~. If ~:re-error~ is nil a warning will be issued on encountering a handled condition and the condition will be returned. One can specify which conditions to handle with ~:handle-conditions~, which accepts an (unquoted) type specifier. One cannot handle no conditions (that defeats the purpose of ~with-atomic-setv~). 
   
   An example: 
#+BEGIN_SRC lisp
  (with-atomic-setv (:re-error nil)
    (error "hello")
    "return string")

  WARNING: WITH-ATOMIC-SETV encountered the error
  #<SIMPLE-ERROR "hello" {address}>
  and reset.
  => #<SIMPLE-ERROR "hello" {address}>

  (with-atomic-setv (:re-error nil :handle-conditions config-error)
    (error "hello")
    "return string")

  drops into the debugger

  (with-atomic-setv (:re-error nil)
    (warn "hello")
    "return string")

  WARNING: hello
  => "return string"

  (with-atomic-setv (:re-error nil :handle-conditions (or error warning))
    (warn "hello")
    "return string")

  WARNING: hello
  => #<SIMPLE-WARNING "hello" {address}>
#+END_SRC

