#+TITLE: DEFCONFIG

* Purpose
  Defconfig is a customization and validation framework for places in CL. Its intended use is with user-exposed variables and accessors, to protect users from setting variables to an invalid value an potentially encountering undefined behavior. It can be used with both dynamic variables and ~setf~-able functions. It coexists alongside ~setf~, and does not replace it - ie you can still use ~setf~ if you want to avoid validating the value. 

* Usage
  The basic usage of this system is through the macros ~defconfig~, ~setv~ and ~with-atomic-setv~. The macro ~defconfig~ defines a configuration object which is used to check values against a predicate. The macro ~setv~ uses these configuration objects to validate values before calling setf. An error is signalled if A) the value is invalid, B) the coerced value is invalid (when applicable) or C) the place one is trying to set doesnt have a configuration object. For A and B, restarts are put into place to ignore the invalidity and set regardless. The macro ~with-atomic-setv~ collects all places set with ~setv~ in its body and if an error is signalled resets all changed values back to their original value before the ~with-atomic-setv~ form. 

* Regarding This Readme
  This readme is not a complete explanation of defconfig. Please see =package.lisp= for a list of exported symbols and see the symbol docstrings for a better idea of what the function/macro/generic/error/etc does. Most (exported) functions/macros are well documented, accessors have decent slot documentation describing their purpose/use, and errors should be grokkable from their ~:report~ functions. Do note that currently accessors are exported, but they should not be depended upon, and instead readers will be exported once they are written. 

* In Depth Usage
  Lets look at an example where one is defining a user-exposed variable for the background color of an application. We will define a configuration object which checks that the value is indeed a color, and a coercer that tries to parse invalid values into a color object. finally we will use ~setv~ and ~with-atomic-setv~ to modify this value. 
** Setup 
   ~(defpackage :my-app (:use :cl))~
** Defconfig
   Here we define a variable called ~*background-color*~ which holds a default value of the color white. It may only hold a color object. If we try to set it to a string, we try to parse a color object from the string. If that fails or we get something other than a string, we return the original value. We do this because value has been determined to be invalid before our coercer got called, and if we cannot make a color we want to be certain that we return an invalid value. We then tag the configuration object with "color" and "background" such that it can be searched for by those names.
#+BEGIN_SRC lisp
  (in-package :my-app)

  (defconfig:defconfig *background-color* (make-color :r 256 :g 256 :b 256)
    :documentation "the background color for my app"
    :typespec 'color
    :coercer (lambda (value)
	       (typecase value
		 (string (or (parse-color-from-string value)
			     value)
		 (t value)))
    :tags '("color" "background"))
#+END_SRC
** Setv
   Now, somewhere in the users =~/.myapp.d/init=, they want to set the background color to black. Lets look at three examples of that: 
#+BEGIN_SRC lisp
  (defconfig:setv *background-color* (make-color :r 0 :g 0 :b 0))
  (defconfig:setv *background-color* "#000000")
  (defconfig:setv *background-color* "i dont know what this user is thinking!")
#+END_SRC
   The first of these works without a hitch; ~setv~ determines that it is a valid value as per the typespec the user provided, and sets ~*background-color*~ to black. The second of these would fail if we hadnt provided a coercer, but as we did, and it knows how to handle color strings, we generate a color from the color string and ~*background-color*~ gets set to black. The third of these is also a string, but its impossible to parse a color from it. Assuming ~parse-color-from-string~ returns ~nil~ on invalid strings, we return value and signal an error. ~*background-color*~ remains white. 
** With-atomic-setv 
   Lets look at an example of ~with-atomic-setv~. We will define a bounded number variable, and then try setting it while signalling various errors. 
#+BEGIN_SRC lisp
  (in-package :defconfig)

  (defconfig *bounded-number* 0
    :typespec '(integer 0 10)
    :coercer (lambda (x)
	       (if (stringp x)
		   (handler-case (parse-integer x)
		     (error () x))
		   x)))

  (with-atomic-setv ()
    (setv *bounded-number* 1)
    (setv *bounded-number* 50))

  (with-atomic-setv ()
    (setv *bounded-number* 1)
    (compute-something-that-signals-an-error)
    (setv *bounded-number* 2))

  (with-atomic-setv (:handle-errors (config-error))
    (setv *bounded-number* 1)
    (compute-something-that-signals-an-error)
    (setv *bounded-number* 2))
#+END_SRC
   The first of the calls to ~with-atomic-setv~ first sets ~*bounded-number*~ to ~1~, and then encounters an error when trying to set it to ~50~. It catches that error and resets ~*bounded-number*~ to 0. 
   The second of these first sets ~*bounded-number*~ to ~1~, and then an error is signalled by ~(compute-something-that-signals-an-error)~. It catches this error and resets ~*bounded-number*~ to 0. 
   The third of these first sets ~*bounded-number*~ to ~1~, and then an error is signalled that it is not set up to handle. Whether or not it attempts to set ~*bounded-number*~ to ~2~ is determined by what handlers and restarts are set up around the error. If there is a restart that doesnt unwind the stack then ~*bounded-number*~ will be set to ~2~, but if there is a non-local transfer of control to a point outside of ~with-atomic-setv~ then ~*bounded-number*~ will remain set to ~1~. 
* A Note About Reset-Place
  The macro ~reset-place~ (and by extension the function ~reset-computed-place~) could be a little confusing. It takes a place, and resets it to its default value. However if ~previous-value~ is true, then it resets to the previous value instead. Before setting, it checks if the current value is eql to the value to reset to (this can be controlled with ~already-reset-test~) and if it is it isnt reset as it would have no effect. If it isnt, we both reset the place, AND set the ~previous-value~ slot to the (now no longer) current value. thusly, if the default value is a, previous value is b, and current value is c, and we reset to the default value, we will have a default of a, previous of c, and current of a. If we had instead reset to the previous value, we effectively swap the previous and current values. 
  Furthermore, we cannot reset any accessor places at the moment

* Macros
** Defconfig
   The ~defconfig~ macro generates a config-info object and registers it in a database. The signature is *defconfig* /place default-value &key validator valid-values coercer reinitialize regen-config test documentation tags/ => /config-info/
*** Arguments and Values
**** place
     a place to register a config-info object for. This should be the same as what you would use in ~setf~. If this is a symbol it is placed in the variable hash. if it is a list, it is placed in the accessor hash. When being placed in the accessor hash, there are two possible config-info objects. If the list is of length one, we register a config-info object for all calls to that accessor. If the list length is greater than one, we register a config-info object for that accessor and argument. Hence, we can have a config-info object for ~(accessor ...)~ and an object for ~(accessor *somevar*)~. When we use ~setv~ on ~(accessor *somevar*)~ we will use second object, but if we use it on ~(accessor *othervar*)~ we will use the first object. 
**** default-value 
     This is the default value for place /place/. It is stored in the config-info object. 
**** validator
     This is the predicate used to validate potential values. It must take one argument and return truthy or false. 
**** typespec
     When provided, a predicate function is built to check any potential values against this typespec. /typespec/ and /validator/ are mutually exclusive. If neither are provided, the identity function is used for /validator/.
**** coercer
     When provided, coercion is attempted on any invalid values using this function. This function should return the original value if it is unable to coerce a value acceptably. 
**** reinitialize
     When truthy, variables will be created/reinitialized using defparameter. When /place/ is an accessor, it is set to /default-value/ using ~setf~. 
**** regen-config
     When true, the config-info object is regenerated, regardless of whether it exists or not. 
**** documentation
     the docstring for /place/, stored in the config-info object. If place is a variable, then the appropriate ~def(var|parameter)~ form is generated to use it. 
**** tags
     These are used for searching for a config-info object. 
**** db
     The database into which the resulting config-info object will be placed. A database can be generated with ~make-config-database~.
** Setv
   The ~setv~ macro expands into multiple calls to ~%setv~, which validates a value before setting the place to it. It functions the same as ~setf~, but accepts the keyword ~:db~ to specify a database other than the default one provided by ~defconfig~. 
** Setv-atomic
   The ~setv-atomic~ macro functions the same as ~setv~, but if any errors are encountered all places are reset to their original value. 
** With-atomic-setv
   The ~with-atomic-setv~ macro resets any places set with ~setv~ to the value the held before ~with-atomic-setv~ when an error is encountered. Unless ~:re-error~ is nil, ~setv-wrapped-error~ is signalled with the ~condition~ slot holding our original error. If no condition is signalled the final form of ~body~ is returned. 
** Reset-place 
   The ~reset-place~ macro resets the place to the default value provided by the corresponding config-info object found within the database. If no object is found ~no-config-found-error~ is signalled.

* Functions
** make-config-database 
   This function takes no arguments and returns a config database. 
** config-info-search 
   This function takes a /term/ to search for, and key arguments for the database and the namespace to search within. /Term/ can be a string, a list of strings, or a symbol/accessor. /Namespace/ is only used when /term/ is a string or list of strings. /Db/ specifies the database to look things up in. 
* Errors
** Invalid-datum-error  
   This error is signalled if one tries to set a place to an invalid value. 
** invalid-coerced-datum-error
   This error is signalled instead of ~invalid-datum-error~ when a place has a coercer registered for it. It inherits from ~invalid-datum-error~. 
** no-config-found-error
   This error is signalled if a place has no config registered for it. 
